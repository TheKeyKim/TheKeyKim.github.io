<!DOCTYPE html><html lang="en-US" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[백준] 10868 - 최솟값 C++" /><meta name="author" content="TheKeyKim" /><meta property="og:locale" content="en_US" /><meta name="description" content="문제링크 10806 - 최솟값 문제 N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자." /><meta property="og:description" content="문제링크 10806 - 최솟값 문제 N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자." /><link rel="canonical" href="https://thekeykim.github.io/posts/BOJ_10868/" /><meta property="og:url" content="https://thekeykim.github.io/posts/BOJ_10868/" /><meta property="og:site_name" content="인간 개발자 김덕휘" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-03-10T21:29:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[백준] 10868 - 최솟값 C++" /><meta name="twitter:site" content="@TheKeyKim" /><meta name="twitter:creator" content="@TheKeyKim" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"headline":"[백준] 10868 - 최솟값 C++","dateModified":"2021-04-01T17:03:41+09:00","datePublished":"2021-03-10T21:29:00+09:00","description":"문제링크 10806 - 최솟값 문제 N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.","url":"https://thekeykim.github.io/posts/BOJ_10868/","mainEntityOfPage":{"@type":"WebPage","@id":"https://thekeykim.github.io/posts/BOJ_10868/"},"@type":"BlogPosting","author":{"@type":"Person","name":"TheKeyKim"},"@context":"https://schema.org"}</script><title>[백준] 10868 - 최솟값 C++ | 인간 개발자 김덕휘</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><style> #sidebar{ background-image : url("/images/main1.jpg"); background-position : center; background-repeat : false; background-size: cover; } #sidebar .nav-item.active .nav-link { color: #fcfcfc; font-size: 20px; } #sidebar a { color: #dbdadaf6; transition: color 0.35s ease-in-out; user-select: none; }</style><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/images/profile.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">인간 개발자 김덕휘</a></div><div class="site-subtitle font-italic">레벨 업 중입니다</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/TheKeyKim" aria-label="github" target="_blank" rel="noopener" > <i class="fab fa-github-alt"></i> </a> <a href="https://www.facebook.com/profile.php?id=100003536463859" aria-label="twitter" target="_blank" rel="noopener" > <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['df1097','naver.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[백준] 10868 - 최솟값 C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[백준] 10868 - 최솟값 C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 10, 2021, 9:29 PM +0900" > Mar 10 <i class="unloaded">2021-03-10T21:29:00+09:00</i> </span> by <span class="author"> TheKeyKim </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 1, 2021, 5:03 PM +0900" > Apr 1 <i class="unloaded">2021-04-01T17:03:41+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1661 words">9 min</span></div></div><div class="post-content"><h1 id="문제링크">문제링크</h1><hr /><p><a href="https://www.acmicpc.net/problem/10868">10806 - 최솟값</a></p><h1 id="문제">문제</h1><hr /><div id="problem_description" class="problem-text"><p>N(1 ≤ N ≤ 100,000)개의 정수들이 있을 때, a번째 정수부터 b번째 정수까지 중에서 제일 작은 정수를 찾는 것은 어려운 일이 아니다. 하지만 이와 같은 a, b의 쌍이 M(1 ≤ M ≤ 100,000)개 주어졌을 때는 어려운 문제가 된다. 이 문제를 해결해 보자.</p><p>여기서 a번째라는 것은 입력되는 순서로 a번째라는 이야기이다. 예를 들어 a=1, b=3이라면 입력된 순서대로 1번, 2번, 3번 정수 중에서 최솟값을 찾아야 한다. 각각의 정수들은 1이상 1,000,000,000이하의 값을 갖는다.</p></div><h1 id="입력">입력</h1><p>첫째 줄에 N, M이 주어진다. 다음 N개의 줄에는 N개의 정수가 주어진다. 다음 M개의 줄에는 a, b의 쌍이 주어진다.</p><h1 id="풀이-유형">풀이 유형</h1><hr /><p><a href="/tags/segtree">세그먼트 트리</a></p><h1 id="풀이">풀이</h1><hr /><p>해당 문제를 풀기 위해서는 세그먼트 트리에 대하여 알아야 한다. 세그먼트 트리는 생각보다 매우 간단한 자료구조다. 그림으로 설명해보겠다.<br /> 여기 아래와 같은 수열이 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>arr = [7,8,6,5,3,9,11,1,2,9,3,8,1,0,5,6]
</pre></table></code></div></div><p>해당 배열의 숫자들을 포화이진트리의 리프 노드에 채운다. 만약 수의 개수가 2의 거듭제곱수가 아닐 경우 완전이진트리를 이용하여 하는 방법도 있지만, 빠른 이해를 위해 포화이진트리를 예시로 들겠다. 만약, 개수가 2의 거듭제곱수가 아닐 경우 MAX값으로 채워놓도록 하자. <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../images/10868_0.png" /><br /> 이제 우리는 부모노드를 채워주어야 한다. 부모노드는 자식 노드 중 작은 수의 데이터를 본 노드의 데이터로 삼는다. <br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../images/10868_1.png" /><br /> 이와 같은 방식으로 위로 위로 트리를 키워 간다.<br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../images/10868_2.png" /><br /> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="../../images/10868_3.png" /><br /> 세그먼트 트리가 완성되었다. 트리빌딩을 하는데에는 O(n)의 시간이 소요 된다. 코드로 한 번 보자.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">tree_building</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span> <span class="c1">// 리프 노드 채우기</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">lll</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">rll</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span> <span class="c1">// 리프노드에서 시작해서 부모노드 채우기</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lll</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">lll</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rll</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">rll</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>정확히는 2*n번 만큼 순회한다. 트리 빌딩에 소요되는 시간은 O(2n) = O(n)이다. <br /> 이제는 해당 문제가 어려워진 이유, ‘쿼리’를 처리해줄 차례다. 잘보면 트리 빌딩 단계에서 lll과 rll이라는 변수가 보일 것이다. lll(Left Limit Line), rll(Right Limit Line)으로 해당 노드의 자식 노드가 갖는 범위를 의미한다. 당연히 왼쪽 자식의 시작점, 오른쪽 자식의 끝점이 부모 노드의 시작점과 끝점이 될 것이다. <br /> 이제 쿼리문을 처리해줄 차례다.</p><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">tree_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lll</span> <span class="o">==</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">rll</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span> <span class="c1">// 시작점과 끝점이 같다면, 해당 노드의 데이터를 반환한다.</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">rll</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">);</span> <span class="c1">// 범위 자체가 오른쪽 자식에 포함된다면 오른쪽 자식으로 순회한다.</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">lll</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">l</span><span class="p">);</span> <span class="c1">// 범위 자체가 왼쪽 자식에 포함된다면 왼쪽 자식으로 순회한다.</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span> <span class="c1">//왼쪽 자식과 오른쪽 자식의 범위에 걸쳐 있는 경우</span>
        <span class="kt">int</span> <span class="n">lret</span> <span class="o">=</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">rll</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rret</span> <span class="o">=</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">lll</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">lret</span><span class="p">,</span> <span class="n">rret</span><span class="p">);</span> <span class="c1">// 각각 구해 더 작은 것을 취한다.</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>조금만 생각해보면 쉽게 이해할 수 있는 코드다. 찾고자하는 범위가 어느쪽 자식의 범위에 포함되는지를 고려해야한다. 그럴 경우 나올 수 있는 경우의 수는 세가지다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>1. 왼쪽 자식의 범위에 전체 범위가 포함되는 경우.
2. 오른쪽 자식의 범위에 전체 범위가 포함되는 경우.
3. 걸쳐 있는 경우.
</pre></table></code></div></div><p>각각 경우에 맞게 분기시켜 재귀함수로 노드들을 순회해주면 O(log n)의 시간에 원하는 답을 찾아낼 수 있다.</p><h1 id="마무리">마무리</h1><hr /><p>그렇게 어렵지 않은 개념이다. 사실 말하자면 dp와도 비슷한 풀이다. 메모이제이션을 통해, 우리는 답을 쉽게 알 수 있다. 세그먼트 트리를 이용해야하는 문제들은 심심치 않게 나온다. 구간합 구하기 문제가 대표적인 예시다. 해당 문제에서는 단순히 작은 값만을 부모 노드의 값으로 삼았다면, 구간합 구하기의 경우 자식의 합을 노드의 값으로 삼는다. 조금 더 나아가면 ‘늦은 전파’를 이용하는 세그먼트 트리 문제도 있는데, 나중에 기회가 되면 다뤄볼 예정이다.</p><h1 id="코드">코드</h1><hr /><div class="language-c++ highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
</pre><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;queue&gt;
#include &lt;cstring&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;stack&gt;
#include &lt;map&gt;
#include &lt;cmath&gt;
</span>
<span class="cp">#define Min(X, Y) ((X) &lt; (Y) ? (X) : (Y))
#define Max(X, Y) ((X) &gt; (Y) ? (X) : (Y))
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Node</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">data</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lll</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">rll</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">num</span><span class="p">[</span><span class="mi">200001</span><span class="p">];</span>
<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
<span class="n">Node</span> <span class="n">tree</span><span class="p">[</span><span class="mi">300001</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">length</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="n">ret</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">tree_building</span><span class="p">(){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">lll</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">rll</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="n">len</span><span class="o">-</span><span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">&gt;=</span><span class="mi">0</span> <span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">data</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lll</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">lll</span><span class="p">;</span>
        <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rll</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">rll</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">tree_find</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">lll</span> <span class="o">==</span> <span class="n">a</span> <span class="o">&amp;&amp;</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">rll</span> <span class="o">==</span> <span class="n">b</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">data</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">rll</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">r</span><span class="p">);</span>
    <span class="p">}</span><span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">lll</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">l</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="kt">int</span> <span class="n">lret</span> <span class="o">=</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">rll</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">rret</span> <span class="o">=</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="n">r</span><span class="p">].</span><span class="n">lll</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">min</span><span class="p">(</span><span class="n">lret</span><span class="p">,</span> <span class="n">rret</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
    <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">N</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="mi">111</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">num</span><span class="p">));</span>
    <span class="n">len</span> <span class="o">=</span> <span class="n">length</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">;</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span><span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
        <span class="n">num</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">tree_building</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span> <span class="n">scanf</span><span class="p">(</span><span class="s">"%d %d"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">m</span><span class="p">);</span> <span class="n">n</span><span class="o">--</span><span class="p">;</span> <span class="n">m</span><span class="o">--</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">anw</span> <span class="o">=</span> <span class="n">tree_find</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">m</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">anw</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EB%B0%B1%EC%A4%80/'>백준</a>, <a href='/categories/c/'>C++</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/c/" class="post-tag no-text-decoration" >C++</a> <a href="/tags/%EB%B0%B1%EC%A4%80/" class="post-tag no-text-decoration" >백준</a> <a href="/tags/segtree/" class="post-tag no-text-decoration" >segTree</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[백준] 10868 - 최솟값 C++ - 인간 개발자 김덕휘&url=https://thekeykim.github.io/posts/BOJ_10868/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[백준] 10868 - 최솟값 C++ - 인간 개발자 김덕휘&u=https://thekeykim.github.io/posts/BOJ_10868/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[백준] 10868 - 최솟값 C++ - 인간 개발자 김덕휘&url=https://thekeykim.github.io/posts/BOJ_10868/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/BOJ_18227/">[백준] 18227 - 성대나라의 물탱크 C++</a><li><a href="/posts/BOJ_3954/">[백준] 3954 - Brainf**k 인터프리터 C++</a><li><a href="/posts/BOJ_1102/">[백준] 1102 - 발전소 C++</a><li><a href="/posts/BOJ_2749/">[백준] 2749 - 피보나치3 C++</a><li><a href="/posts/BOJ_10868/">[백준] 10868 - 최솟값 C++</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/dp/">dp</a> <a class="post-tag" href="/tags/math/">math</a> <a class="post-tag" href="/tags/segtree/">segTree</a> <a class="post-tag" href="/tags/bitmask/">bitmask</a> <a class="post-tag" href="/tags/comb/">comb</a> <a class="post-tag" href="/tags/divide-and-conquer/">divide-and-conquer</a> <a class="post-tag" href="/tags/impl/">impl</a> <a class="post-tag" href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a></div></div></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/BOJ_18227/"><div class="card-body"> <span class="timeago small" > Apr 4 <i class="unloaded">2021-04-04T16:55:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준] 18227 - 성대나라의 물탱크 C++</h3><div class="text-muted small"><p> 문제링크 18227 - 성대나라의 물탱크 문제 성대나라에는 각 도시별로 가뭄을 대비하기 위한 물탱크가 하나씩 존재한다. 이 물탱크들은 모두 연결되어있으며, 루트(성대나라의 수도)가 있는 트리의 형태를 가진다. 지금 성대나라는 물탱크의 물을 사용하여 가뭄을 버텨냈으나, 그 영향으로 모든 물탱크에 물이 비어버리고 말았다. 성대나라의 물관리 ...</p></div></div></a></div><div class="card"> <a href="/posts/BOJ_3954/"><div class="card-body"> <span class="timeago small" > Feb 23 <i class="unloaded">2021-02-23T18:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준] 3954 - Brainf**k 인터프리터 C++</h3><div class="text-muted small"><p> 문제링크 3954 - Brainf**k 인터프리터 문제 Brainf**k 프로그램이 주어졌을 때, 이 프로그램이 끝나는지, 무한 루프에 빠지는지 알아내는 프로그램을 작성하시오. 무한 루프란, 특정 시점부터 탈출하지 않고 무한히 반복 실행되는 루프를 말한다. Brainf**k 인터프리터는 정수를 담는 하나의 배열(unsigned 8-...</p></div></div></a></div><div class="card"> <a href="/posts/BOJ_1102/"><div class="card-body"> <span class="timeago small" > Feb 24 <i class="unloaded">2021-02-24T23:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[백준] 1102 - 발전소 C++</h3><div class="text-muted small"><p> 문제링크 1102 - 발전소 문제 은진이는 발전소에서 근무한다. 은진이가 회사에서 잠깐 잘 때마다, 몇몇 발전소가 고장이난다. 게다가, 지금 은진이의 보스 형택이가 은진이의 사무실로 걸어오고 있다. 만약 은진이가 형택이가 들어오기 전까지 발전소를 고쳐놓지 못한다면, 은진이는 해고당할 것이다. 발전소를 고치는 방법은 간단하다. 고장나지...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/BOJ_2749/" class="btn btn-outline-primary" prompt="Older"><p>[백준] 2749 - 피보나치3 C++</p></a> <a href="/posts/BOJ_1801/" class="btn btn-outline-primary" prompt="Newer"><p>[백준] 1801 - 직사각형 만들기 C++</p></a></div></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://twitter.com/">김덕휘</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/c/">C++</a> <a class="post-tag" href="/tags/%EB%B0%B1%EC%A4%80/">백준</a> <a class="post-tag" href="/tags/dp/">dp</a> <a class="post-tag" href="/tags/math/">math</a> <a class="post-tag" href="/tags/segtree/">segTree</a> <a class="post-tag" href="/tags/bitmask/">bitmask</a> <a class="post-tag" href="/tags/comb/">comb</a> <a class="post-tag" href="/tags/divide-and-conquer/">divide and conquer</a> <a class="post-tag" href="/tags/impl/">impl</a> <a class="post-tag" href="/tags/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98/">알고리즘</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://thekeykim.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
